import React, { useState, useEffect, useRef, createContext, useContext } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, getDocs } from 'firebase/firestore';

// --- Firebase Context and Provider ---
const FirebaseContext = createContext(null);

const FirebaseProvider = ({ children }) => {
  const [app, setApp] = useState(null);
  const [db, setDb] = useState(null);
  const [auth, setAuth] = useState(null);
  const [userId, setUserId] = useState(null);
  const [isAuthReady, setIsAuthReady] = useState(false);

  useEffect(() => {
    try {
      // Initialize Firebase app
      const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
      const firebaseApp = initializeApp(firebaseConfig);
      setApp(firebaseApp);

      // Initialize Firebase services
      const firestoreDb = getFirestore(firebaseApp);
      setDb(firestoreDb);

      const firebaseAuth = getAuth(firebaseApp);
      setAuth(firebaseAuth);

      // Authenticate user
      const authenticateUser = async () => {
        try {
          if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
            await signInWithCustomToken(firebaseAuth, __initial_auth_token);
          } else {
            await signInAnonymously(firebaseAuth);
          }
        } catch (error) {
          console.error("Ошибка аутентификации Firebase:", error);
          // Fallback to anonymous if custom token fails
          await signInAnonymously(firebaseAuth);
        }
      };

      authenticateUser();

      // Listen for auth state changes
      const unsubscribe = onAuthStateChanged(firebaseAuth, (user) => {
        if (user) {
          setUserId(user.uid);
        } else {
          setUserId(null);
        }
        setIsAuthReady(true); // Auth state is ready
      });

      return () => unsubscribe(); // Cleanup auth listener
    } catch (error) {
      console.error("Ошибка инициализации Firebase:", error);
      setIsAuthReady(true); // Mark as ready even on error to unblock UI
    }
  }, []);

  return (
    <FirebaseContext.Provider value={{ app, db, auth, userId, isAuthReady }}>
      {children}
    </FirebaseContext.Provider>
  );
};

// Custom hook to use Firebase context
const useFirebase = () => useContext(FirebaseContext);

// --- Google Maps Script Loader ---
const useGoogleMaps = (apiKey) => {
  const [scriptLoaded, setScriptLoaded] = useState(false);
  const [mapError, setMapError] = useState(null);

  useEffect(() => {
    if (!apiKey) {
      setMapError("Отсутствует API-ключ Google Maps. Пожалуйста, вставьте его.");
      return;
    }

    const existingScript = document.getElementById('google-maps-script');
    if (existingScript) {
      setScriptLoaded(true);
      return;
    }

    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=geometry`;
    script.id = 'google-maps-script';
    script.async = true;
    script.defer = true;
    document.head.appendChild(script);

    script.onload = () => {
      console.log("Скрипт Google Maps загружен.");
      setScriptLoaded(true);
    };

    script.onerror = () => {
      console.error("Ошибка загрузки скрипта Google Maps.");
      setMapError("Не удалось загрузить Google Maps. Проверьте API-ключ и подключение к интернету.");
    };

    return () => {
      // Clean up script if component unmounts before load (unlikely for main app)
      // if (script.parentNode) {
      //   script.parentNode.removeChild(script);
      // }
    };
  }, [apiKey]);

  return { scriptLoaded, mapError };
};

// --- Utility Functions ---
const calculateDistance = (lat1, lon1, lat2, lon2) => {
  const R = 6371e3; // metres
  const φ1 = lat1 * Math.PI / 180; // φ, λ in radians
  const φ2 = lat2 * Math.PI / 180;
  const Δφ = (lat2 - lat1) * Math.PI / 180;
  const Δλ = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  const d = R * c; // in metres
  return d;
};

const formatTime = (seconds) => {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = Math.floor(seconds % 60);
  return [h, m, s].map(v => v < 10 ? "0" + v : v).filter((v, i) => v !== "00" || i > 0).join(":");
};

const formatDistance = (meters) => {
  if (meters < 1000) {
    return `${meters.toFixed(0)} м`;
  }
  return `${(meters / 1000).toFixed(2)} км`;
};

const formatSpeed = (mps) => {
  const kmph = mps * 3.6;
  return `${kmph.toFixed(1)} км/ч`;
};

// --- Components ---

const Button = ({ children, onClick, className = '', disabled = false }) => (
  <button
    onClick={onClick}
    disabled={disabled}
    className={`
      px-6 py-3 rounded-xl shadow-lg transition-all duration-300
      font-semibold text-white bg-gradient-to-br from-blue-500 to-blue-700
      hover:from-blue-600 hover:to-blue-800 active:from-blue-700 active:to-blue-900
      disabled:opacity-50 disabled:cursor-not-allowed disabled:from-gray-400 disabled:to-gray-600
      ${className}
    `}
  >
    {children}
  </button>
);

const Card = ({ children, className = '' }) => (
  <div className={`bg-white rounded-xl shadow-lg p-6 ${className}`}>
    {children}
  </div>
);

const Input = ({ type = 'text', placeholder, value, onChange, className = '' }) => (
  <input
    type={type}
    placeholder={placeholder}
    value={value}
    onChange={onChange}
    className={`
      w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500
      ${className}
    `}
  />
);

const Select = ({ children, value, onChange, className = '' }) => (
  <select
    value={value}
    onChange={onChange}
    className={`
      w-full px-4 py-2 border border-gray-300 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-blue-500
      ${className}
    `}
  >
    {children}
  </select>
);

const Modal = ({ isOpen, onClose, title, children }) => {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <Card className="max-w-md w-full relative">
        <h2 className="text-2xl font-bold mb-4 text-gray-800">{title}</h2>
        <button
          onClick={onClose}
          className="absolute top-4 right-4 text-gray-500 hover:text-gray-700 text-2xl"
        >
          &times;
        </button>
        <div className="mt-4">
          {children}
        </div>
      </Card>
    </div>
  );
};

const LoginScreen = ({ onLoginSuccess }) => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleLogin = () => {
    if (username === 'Renard' && password === '121212') {
      onLoginSuccess();
    } else {
      setError('Неверный логин или пароль.');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-purple-400 to-blue-600 p-4">
      <Card className="w-full max-w-sm text-center">
        <h1 className="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-700 mb-6">
          SprintTrack
        </h1>
        <p className="text-gray-600 mb-8">Войдите, чтобы начать отслеживание!</p>
        <div className="space-y-4">
          <Input
            placeholder="Логин"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
          />
          <Input
            type="password"
            placeholder="Пароль"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {error && <p className="text-red-500 text-sm">{error}</p>}
          <Button onClick={handleLogin} className="w-full">
            Войти
          </Button>
        </div>
      </Card>
    </div>
  );
};

const DashboardScreen = ({ googleMapsApiKey }) => {
  const { db, userId, isAuthReady } = useFirebase();
  const { scriptLoaded, mapError } = useGoogleMaps(googleMapsApiKey);

  const mapRef = useRef(null);
  const mapInstance = useRef(null);
  const marker = useRef(null);
  const polyline = useRef(null);
  const watchId = useRef(null);

  const [isTracking, setIsTracking] = useState(false);
  const [currentLocation, setCurrentLocation] = useState(null);
  const [path, setPath] = useState([]);
  const [distance, setDistance] = useState(0);
  const [speed, setSpeed] = useState(0);
  const [time, setTime] = useState(0);
  const timerInterval = useRef(null);
  const lastPosition = useRef(null);

  const [selectedMode, setSelectedMode] = useState('Ходьба');
  const [showShareModal, setShowShareModal] = useState(false);
  const [shareLink, setShareLink] = useState('');

  const [userStats, setUserStats] = useState({ totalDistance: 0, totalRoutes: 0 });
  const [recentRoutes, setRecentRoutes] = useState([]);

  const modeOptions = {
    'Пешком': ['Спринт', 'Ходьба', 'Бег', 'Хайкинг'],
    'Велосипед': ['Сбалансированный', 'Самый короткий', 'Велосипедные дорожки', 'Популярные', 'E-bike', 'Плавная езда', 'Шоссейный велосипед', 'Горный велосипед']
  };

  const currentModeCategory = Object.keys(modeOptions).find(category => modeOptions[category].includes(selectedMode));

  // --- Firebase Data Fetching ---
  useEffect(() => {
    if (!db || !userId || !isAuthReady) return;

    // Listen for user stats
    const userProfileDocRef = doc(db, `artifacts/${__app_id}/users/${userId}/profiles/main`);
    const unsubscribeStats = onSnapshot(userProfileDocRef, (docSnap) => {
      if (docSnap.exists()) {
        setUserStats(docSnap.data());
      } else {
        // Initialize user profile if it doesn't exist
        setDoc(userProfileDocRef, { totalDistance: 0, totalRoutes: 0 }, { merge: true });
        setUserStats({ totalDistance: 0, totalRoutes: 0 });
      }
    }, (error) => {
      console.error("Ошибка получения статистики пользователя:", error);
    });

    // Listen for recent routes (last 5-6)
    const routesCollectionRef = collection(db, `artifacts/${__app_id}/users/${userId}/routes`);
    const unsubscribeRoutes = onSnapshot(routesCollectionRef, async (snapshot) => {
      const routes = [];
      snapshot.forEach(doc => {
        routes.push({ id: doc.id, ...doc.data() });
      });
      // Sort by timestamp and take last 6
      const sortedRoutes = routes.sort((a, b) => b.startTime - a.startTime).slice(0, 6);
      setRecentRoutes(sortedRoutes);
    }, (error) => {
      console.error("Ошибка получения недавних маршрутов:", error);
    });

    return () => {
      unsubscribeStats();
      unsubscribeRoutes();
    };
  }, [db, userId, isAuthReady]);

  // --- Google Maps Initialization ---
  useEffect(() => {
    if (scriptLoaded && window.google && mapRef.current && !mapInstance.current) {
      console.log("Инициализация карты Google Maps...");
      mapInstance.current = new window.google.maps.Map(mapRef.current, {
        center: { lat: 0, lng: 0 }, // Default center, will update with user location
        zoom: 15,
        mapTypeId: window.google.maps.MapTypeId.SATELLITE, // Satellite view
        disableDefaultUI: true, // Hide default UI for cleaner look
        zoomControl: true,
        scaleControl: true,
      });

      marker.current = new window.google.maps.Marker({
        map: mapInstance.current,
        position: { lat: 0, lng: 0 },
        icon: {
          path: window.google.maps.SymbolPath.CIRCLE,
          scale: 8,
          fillColor: '#4285F4', // Google Blue
          fillOpacity: 1,
          strokeWeight: 2,
          strokeColor: '#FFFFFF', // White border
        },
      });

      polyline.current = new window.google.maps.Polyline({
        path: [],
        geodesic: true,
        strokeColor: '#FF0000', // Red path
        strokeOpacity: 0.8,
        strokeWeight: 5,
        map: mapInstance.current,
      });

      // Try to get current location immediately after map loads
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            const pos = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
            };
            mapInstance.current.setCenter(pos);
            marker.current.setPosition(pos);
            setCurrentLocation(pos);
          },
          (error) => {
            console.error("Ошибка получения текущего местоположения:", error);
            // Fallback to a default location if geolocation fails
            mapInstance.current.setCenter({ lat: 51.169392, lng: 71.449074 }); // Astana, Kazakhstan
          },
          { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
        );
      }
    }
  }, [scriptLoaded, mapError]);

  // --- Tracking Logic ---
  const startTracking = () => {
    if (!scriptLoaded || !mapInstance.current) {
      alert("Карта не загружена. Пожалуйста, подождите или проверьте API-ключ.");
      return;
    }

    if (navigator.geolocation) {
      setIsTracking(true);
      setPath([]);
      setDistance(0);
      setTime(0);
      setSpeed(0);
      lastPosition.current = null;

      timerInterval.current = setInterval(() => {
        setTime(prevTime => prevTime + 1);
      }, 1000);

      watchId.current = navigator.geolocation.watchPosition(
        (position) => {
          const newPos = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          };
          const newSpeed = position.coords.speed !== null ? position.coords.speed : 0; // m/s

          setCurrentLocation(newPos);
          mapInstance.current.setCenter(newPos);
          marker.current.setPosition(newPos);
          setSpeed(newSpeed);

          setPath(prevPath => {
            const updatedPath = [...prevPath, newPos];
            if (lastPosition.current) {
              const dist = calculateDistance(
                lastPosition.current.lat,
                lastPosition.current.lng,
                newPos.lat,
                newPos.lng
              );
              setDistance(prevDist => prevDist + dist);
            }
            lastPosition.current = newPos;
            polyline.current.setPath(updatedPath);
            return updatedPath;
          });
        },
        (error) => {
          console.error("Ошибка отслеживания местоположения:", error);
          alert(`Ошибка GPS: ${error.message}. Убедитесь, что GPS включен и разрешен для сайта.`);
          stopTracking(); // Stop tracking on error
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    } else {
      alert("Геолокация не поддерживается вашим браузером.");
    }
  };

  const stopTracking = async () => {
    if (watchId.current) {
      navigator.geolocation.clearWatch(watchId.current);
      watchId.current = null;
    }
    if (timerInterval.current) {
      clearInterval(timerInterval.current);
      timerInterval.current = null;
    }
    setIsTracking(false);

    // Save route to Firebase
    if (db && userId && path.length > 1) {
      const routeData = {
        startTime: Date.now(),
        endTime: Date.now() + time * 1000, // Approximate end time
        distance: distance,
        duration: time,
        avgSpeed: distance / time || 0,
        mode: selectedMode,
        path: JSON.stringify(path), // Store path as string to avoid Firestore limitations
        userId: userId,
      };

      try {
        const routesCollectionRef = collection(db, `artifacts/${__app_id}/users/${userId}/routes`);
        await setDoc(doc(routesCollectionRef), routeData); // Use setDoc with auto-generated ID

        // Update user's total stats
        const userProfileDocRef = doc(db, `artifacts/${__app_id}/users/${userId}/profiles/main`);
        await updateDoc(userProfileDocRef, {
          totalDistance: (userStats.totalDistance || 0) + distance,
          totalRoutes: (userStats.totalRoutes || 0) + 1,
        });
        console.log("Маршрут сохранен и статистика обновлена!");
      } catch (e) {
        console.error("Ошибка сохранения маршрута или обновления статистики:", e);
      }
    }

    // Reset map polyline
    if (polyline.current) {
      polyline.current.setPath([]);
    }
  };

  const handleShareRoute = (routeId) => {
    // In a real app, this would generate a unique shareable URL
    // For this demo, we'll just show a placeholder link
    const link = `https://sprinttrack.app/route/${routeId}`;
    setShareLink(link);
    setShowShareModal(true);
  };

  const copyShareLink = () => {
    const el = document.createElement('textarea');
    el.value = shareLink;
    document.body.appendChild(el);
    el.select();
    document.execCommand('copy');
    document.body.removeChild(el);
    alert('Ссылка скопирована в буфер обмена!');
    setShowShareModal(false);
  };

  if (mapError) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-red-100 text-red-700 p-4 text-center">
        <Card>
          <h2 className="text-2xl font-bold mb-4">Ошибка загрузки карты</h2>
          <p>{mapError}</p>
          <p className="mt-4 text-sm">Пожалуйста, вставьте ваш Google Maps API ключ в код.</p>
        </Card>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex flex-col lg:flex-row bg-gradient-to-br from-indigo-100 to-blue-200 p-4 font-inter">
      {/* Left Panel - Controls and Stats */}
      <div className="lg:w-1/3 w-full lg:pr-4 mb-4 lg:mb-0 flex flex-col space-y-4">
        <Card className="flex-shrink-0">
          <h2 className="text-2xl font-bold text-gray-800 mb-4">Отслеживание активности</h2>
          <div className="mb-4">
            <label className="block text-gray-700 text-sm font-bold mb-2">
              Тип передвижения:
            </label>
            <Select
              value={currentModeCategory}
              onChange={(e) => setSelectedMode(modeOptions[e.target.value][0])}
              className="mb-2"
            >
              {Object.keys(modeOptions).map(category => (
                <option key={category} value={category}>{category}</option>
              ))}
            </Select>
            <Select
              value={selectedMode}
              onChange={(e) => setSelectedMode(e.target.value)}
            >
              {modeOptions[currentModeCategory].map(mode => (
                <option key={mode} value={mode}>{mode}</option>
              ))}
            </Select>
          </div>

          <div className="flex space-x-4">
            {!isTracking ? (
              <Button onClick={startTracking} disabled={!scriptLoaded || !mapInstance.current} className="flex-1">
                Начать маршрут
              </Button>
            ) : (
              <Button onClick={stopTracking} className="flex-1 bg-gradient-to-br from-red-500 to-red-700 hover:from-red-600 hover:to-red-800">
                Завершить маршрут
              </Button>
            )}
          </div>
        </Card>

        {/* Real-time Stats */}
        <Card className="flex-shrink-0">
          <h3 className="text-xl font-bold text-gray-800 mb-4">Текущие показатели</h3>
          <div className="grid grid-cols-2 gap-4 text-center">
            <div>
              <p className="text-gray-500 text-sm">Дистанция</p>
              <p className="text-2xl font-bold text-blue-600">{formatDistance(distance)}</p>
            </div>
            <div>
              <p className="text-gray-500 text-sm">Время</p>
              <p className="text-2xl font-bold text-blue-600">{formatTime(time)}</p>
            </div>
            <div className="col-span-2">
              <p className="text-gray-500 text-sm">Текущая скорость</p>
              <p className="text-2xl font-bold text-blue-600">{formatSpeed(speed)}</p>
            </div>
          </div>
        </Card>

        {/* Total Stats */}
        <Card className="flex-shrink-0">
          <h3 className="text-xl font-bold text-gray-800 mb-4">Общая статистика</h3>
          <div className="grid grid-cols-2 gap-4 text-center">
            <div>
              <p className="text-gray-500 text-sm">Общая дистанция</p>
              <p className="text-2xl font-bold text-green-600">{formatDistance(userStats.totalDistance || 0)}</p>
            </div>
            <div>
              <p className="text-gray-500 text-sm">Маршрутов</p>
              <p className="text-2xl font-bold text-green-600">{userStats.totalRoutes || 0}</p>
            </div>
          </div>
          <p className="text-xs text-gray-500 mt-4">Ваш ID пользователя: {userId}</p>
        </Card>
      </div>

      {/* Right Panel - Map and History */}
      <div className="lg:w-2/3 w-full flex flex-col space-y-4">
        <Card className="flex-grow min-h-[400px] lg:min-h-0 relative overflow-hidden">
          {scriptLoaded ? (
            <div ref={mapRef} className="w-full h-full rounded-lg"></div>
          ) : (
            <div className="absolute inset-0 flex items-center justify-center bg-gray-100 text-gray-600">
              Загрузка карты...
            </div>
          )}
        </Card>

        {/* Recent Routes */}
        <Card className="flex-shrink-0">
          <h3 className="text-xl font-bold text-gray-800 mb-4">Последние маршруты</h3>
          {recentRoutes.length === 0 ? (
            <p className="text-gray-500">Пока нет завершенных маршрутов.</p>
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {recentRoutes.map(route => (
                <div key={route.id} className="bg-blue-50 p-4 rounded-lg shadow-sm flex flex-col justify-between">
                  <div>
                    <p className="text-md font-semibold text-blue-800">{new Date(route.startTime).toLocaleDateString()} - {route.mode}</p>
                    <p className="text-sm text-gray-600">Дистанция: {formatDistance(route.distance)}</p>
                    <p className="text-sm text-gray-600">Время: {formatTime(route.duration)}</p>
                    <p className="text-sm text-gray-600">Ср. скорость: {formatSpeed(route.avgSpeed)}</p>
                  </div>
                  <Button
                    onClick={() => handleShareRoute(route.id)}
                    className="mt-3 py-2 px-4 text-sm bg-gradient-to-br from-green-400 to-green-600 hover:from-green-500 hover:to-green-700"
                  >
                    Поделиться
                  </Button>
                </div>
              ))}
            </div>
          )}
        </Card>
      </div>

      {/* Share Modal */}
      <Modal isOpen={showShareModal} onClose={() => setShowShareModal(false)} title="Поделиться маршрутом">
        <p className="mb-4 text-gray-700">Скопируйте ссылку, чтобы поделиться своим маршрутом:</p>
        <Input type="text" value={shareLink} readOnly className="mb-4 bg-gray-100" />
        <Button onClick={copyShareLink} className="w-full">
          Скопировать ссылку
        </Button>
      </Modal>
    </div>
  );
};

const App = () => {
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  // Replace 'YOUR_GOOGLE_MAPS_API_KEY' with your actual Google Maps API Key
  const googleMapsApiKey = 'YOUR_GOOGLE_MAPS_API_KEY';

  return (
    <FirebaseProvider>
      {isLoggedIn ? (
        <DashboardScreen googleMapsApiKey={googleMapsApiKey} />
      ) : (
        <LoginScreen onLoginSuccess={() => setIsLoggedIn(true)} />
      )}
    </FirebaseProvider>
  );
};

export default App;
